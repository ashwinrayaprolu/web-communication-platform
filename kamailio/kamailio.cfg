#!KAMAILIO

# Global settings
# Use the actual hostname/IP that clients can reach
# Replace 'kamailio' with your actual hostname or IP
listen=tcp:0.0.0.0:8080 advertise 192.168.2.16:8080
listen=udp:0.0.0.0:5060 advertise 192.168.2.16:5060
listen=tcp:0.0.0.0:5060 advertise 192.168.2.16:5060


# Global parameters
debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# TCP settings
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605
tcp_max_connections=2048

# Children processes
children=4

# DNS settings
dns=no
rev_dns=no

# Module path for both architectures
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/:/usr/lib/aarch64-linux-gnu/kamailio/modules/"

# Load modules
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
#loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "permissions.so"
loadmodule "dispatcher.so"
loadmodule "dialog.so"
#loadmodule "dialplan.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "tls.so"
loadmodule "db_postgres.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "cfgutils.so"
loadmodule "corex.so"
loadmodule "kex.so"
loadmodule "sdpops.so"

# Module parameters
# TM module
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# RR module
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Registrar module
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 3600)
modparam("registrar", "received_avp", "$avp(received)")

# User location module
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "nat_bflag", 6)

# Database connection
modparam("auth_db", "db_url", "postgres://voip_user:voip_pass_2024@postgres/voip_db")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")

# Dispatcher module
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
#modparam("dispatcher", "dst_avp", "$avp(dsdst)")
#modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
#modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
#modparam("dispatcher", "attrs_avp", "$avp(dsattrs)")

# Dialog module
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "timeout_avp", "$avp(dlg_timeout)")
modparam("dialog", "default_timeout", 21600)

# WebSocket module
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)

# NAT helper
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.local")
modparam("nathelper", "received_avp", "$avp(received)")

# RTPEngine module
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_retr", 5)
modparam("rtpengine", "rtpengine_tout_ms", 1000)
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
modparam("rtpengine", "setid_avp", "$avp(setid)")

# Hash table for rate limiting
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

# Pike module for flood detection
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# =============================================================================
# Add at the top with other modparams
# =============================================================================
# Advertise proper addresses in Record-Route
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# =============================================================================
# FLAG DEFINITIONS
# =============================================================================
# Flag 1: acc transaction
# Flag 3: acc failed transaction
# Flag 4: dialog
# Flag 5: NAT flag
# Flag 6: NAT bflag (branch flag)
# Flag 7: sipping flag
# Flag 8: WebRTC flag (NEW - marks WebRTC clients)
# =============================================================================

# Routing logic
request_route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle requests within dialogs
    if (has_totag()) {
        if (loose_route()) {
            route(DLGURI);
            
            # Restore WebRTC flag from route param
            if(check_route_param("webrtc=yes")) {
                xlog("L_INFO", "Restoring WebRTC flag from route param for $ci\n");
                setflag(8);
            }
            
            if (is_method("BYE")) {
                setflag(1);
                setflag(3);
                route(NATMANAGE);  # Call NATMANAGE for BYE (to delete RTPEngine session)
            } else if (is_method("ACK")) {
                # ✅ FIXED: Don't call NATMANAGE for ACK - just relay it
                xlog("L_INFO", "In-dialog ACK detected, relaying without RTPEngine processing\n");
            }
            route(RELAY);
            exit;
        }

        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            } else {
                exit;
            }
        }
        sl_send_reply("404","Not here");
        exit;
    }

    # Initial INVITE
    if (is_method("INVITE")) {
        setflag(1);
        dlg_manage();
    }

    # REGISTER processing
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # ============================================================
    # INVITE PROCESSING WITH LOOP PREVENTION
    # ============================================================
    if (is_method("INVITE")) {
        
        # **CRITICAL: LOOP PREVENTION - Check if call is FROM Drachtio/App**
        # Detect by: X-Call-ID header (added by your Node.js app) OR X-From-App header
        if (is_present_hf("X-Call-ID") || is_present_hf("X-From-App")) {
            xlog("L_INFO", "===== CALL FROM APP/DRACHTIO (BRIDGED): $ci =====\n");
            xlog("L_INFO", "Destination: $rU - Routing directly to registered extension\n");
            
            # This is a bridged call from the app, route directly to destination
            if (registered("location")) {
                xlog("L_INFO", "Extension $rU is registered, routing directly (NO LOOP)\n");
                
                # Lookup the location - this sets $ru to the contact URI
                lookup("location");
                
                # After lookup, $ru contains the actual contact address
                # Check if it contains WebSocket transport
                xlog("L_INFO", "Contact URI after lookup: $ru\n");
                xlog("L_INFO", "Destination URI: $du\n");
                
                # WebRTC clients will have transport=ws or transport=wss in their contact
                if ($ru =~ "transport=ws" || $ru =~ "transport=wss") {
                    xlog("L_INFO", "*** TARGET IS WEBRTC CLIENT - Setting WebRTC flag ***\n");
                    setflag(8);  # Mark as WebRTC for proper RTPEngine handling
                    setflag(5);  # Also set NAT flag
                } else {
                    xlog("L_INFO", "Target extension $rU is regular SIP client\n");
                }
                
                # NATMANAGE will be called in branch_route which will handle RTPEngine
                route(RELAY);
                exit;
            } else {
                xlog("L_WARN", "Extension $rU not registered, returning 404\n");
                send_reply("404", "User Not Found");
                exit;
            }
        }
        
        # **ALL INCOMING CALLS: Route to Drachtio first**
        # Drachtio/App will decide whether to bridge or handle the call
        xlog("L_INFO", "===== NEW INCOMING CALL: $ci =====\n");
        xlog("L_INFO", "From: $fU To: $rU Protocol: $proto\n");
        xlog("L_INFO", "Routing ALL calls to Drachtio for app processing\n");
        
        # Add header to mark this call as initial routing
        append_hf("X-Kamailio-Route: initial\r\n");
        
        # Load balance between Drachtio servers
        if (!ds_select_dst("1", "4")) {
            xlog("L_ERR", "Failed to select Drachtio destination\n");
            send_reply("503", "Service Unavailable - No Drachtio servers available");
            exit;
        }
        
        xlog("L_INFO", "Selected Drachtio destination: $du\n");
        route(RELAY);
        exit;
    }

    # Handle other requests
    route(RELAY);
}

# Request initialization route
route[REQINIT] {
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP request from $si:$sp\n");
        exit;
    }
}

# NAT detection route
route[NATDETECT] {
    force_rport();
    
    # Detect WebRTC clients (WebSocket transport)
    if ($proto == "ws" || $proto == "wss") {
        xlog("L_INFO", "WebRTC client detected (WebSocket transport) for $ci\n");
        setflag(8);  # Mark as WebRTC
        setflag(5);  # Also set NAT flag
    }
    
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
}

# NAT management route
# =============================================================================
# FIXED NAT MANAGEMENT ROUTE
# =============================================================================
# =============================================================================
# NAT MANAGEMENT ROUTE
# =============================================================================
# This route handles:
# 1. NAT detection and traversal
# 2. RTPEngine media processing (WebRTC ↔ RTP conversion)
# 3. Record-Route parameter management for dialog persistence
# =============================================================================
route[NATMANAGE] {
    # -------------------------------------------------------------------------
    # STEP 1: Restore flags from Record-Route parameters (for in-dialog requests)
    # -------------------------------------------------------------------------
    if (is_request()) {
        if(has_totag()) {
            # Check if NAT flag was set in initial INVITE (stored in Record-Route)
            if(check_route_param("nat=yes")) {
                setflag(5);  # Flag 5 = NAT flag
            }
            
            # Check if WebRTC flag was set in initial INVITE (stored in Record-Route)
            if(check_route_param("webrtc=yes")) {
                setflag(8);  # Flag 8 = WebRTC flag
            }
        }
    }
    
    # -------------------------------------------------------------------------
    # STEP 2: Exit early if neither NAT nor branch NAT flag is set
    # -------------------------------------------------------------------------
    # Flag 5: NAT flag (message level)
    # Flag 6: NAT bflag (branch level - set per destination)
    if (!(isflagset(5) || isbflagset(6))) return;

    # -------------------------------------------------------------------------
    # STEP 3: RTPEngine processing for INVITE (SDP Offer)
    # -------------------------------------------------------------------------
    if (is_method("INVITE")) {
        
        # Check if this leg involves WebRTC
        if (isflagset(8)) {
            
            # -----------------------------------------------------------------
            # CASE A: Incoming from WebRTC client → Convert to plain RTP
            # -----------------------------------------------------------------
            # Direction: Browser (WebRTC/SRTP) → Kamailio → Backend (RTP)
            if ($proto == "ws" || $proto == "wss") {
                xlog("L_INFO", "RTPEngine OFFER: WebRTC to RTP conversion (Call-ID: $ci)\n");
                xlog("L_INFO", "  Source: $si:$sp (WebSocket)\n");
                xlog("L_INFO", "  Destination: $du\n");
                
                # RTPEngine parameters explained:
                # - trust-address: Trust the address in SDP (don't replace with source IP)
                # - replace-origin: Replace o= line in SDP with RTPEngine's address
                # - replace-session-connection: Replace c= line in SDP with RTPEngine's address
                # - rtcp-mux-demux: Accept rtcp-mux from client, send separate RTCP to backend
                # - ICE=remove: Remove ICE candidates (backend doesn't support ICE)
                # - DTLS=off: Remove DTLS (backend uses plain SRTP or RTP)
                # - RTP/SAVPF: Input format (WebRTC with SRTP)
                # - RTP/AVP: Output format (plain RTP for backend)
                $var(rtpe_result) = rtpengine_offer("trust-address replace-origin replace-session-connection rtcp-mux-demux ICE=remove DTLS=off RTP/SAVPF RTP/AVP");
                xlog("L_INFO", "  RTPEngine offer result: $var(rtpe_result)\n");
                
            } 
            # -----------------------------------------------------------------
            # CASE B: Outgoing to WebRTC client → Convert plain RTP to WebRTC
            # -----------------------------------------------------------------
            # Direction: Backend (RTP) → Kamailio → Browser (WebRTC/SRTP)
            else {
                xlog("L_INFO", "RTPEngine OFFER: RTP to WebRTC conversion (Call-ID: $ci)\n");
                xlog("L_INFO", "  Source: $si:$sp (SIP)\n");
                xlog("L_INFO", "  Destination: $du (WebSocket)\n");
                
                # RTPEngine parameters explained:
                # - trust-address: Trust the address in SDP
                # - replace-origin: Replace o= line with RTPEngine's address
                # - replace-session-connection: Replace c= line with RTPEngine's address
                # - rtcp-mux-require: Force rtcp-mux (required by WebRTC)
                # - ICE=force: Add ICE candidates (required by WebRTC)
                # - DTLS=passive: Set up DTLS in passive mode (WebRTC will be active)
                # - RTP/AVP: Input format (plain RTP from backend)
                # - RTP/SAVPF: Output format (WebRTC with SRTP)
                $var(rtpe_result) = rtpengine_offer("trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force DTLS=passive RTP/AVP RTP/SAVPF");
                xlog("L_INFO", "  RTPEngine offer result: $var(rtpe_result)\n");
            }
        } 
        # -----------------------------------------------------------------
        # CASE C: Regular SIP client (no WebRTC involved)
        # -----------------------------------------------------------------
        else {
            # Only process if there's SDP in the message
            if (sdp_content()) {
                xlog("L_INFO", "RTPEngine OFFER: Regular SIP (Call-ID: $ci)\n");
                
                # Basic RTPEngine processing for NAT traversal
                # - Just replace addresses, no protocol conversion needed
                rtpengine_offer("trust-address replace-origin replace-session-connection RTP/AVP");
            }
        }
    } 
    # -------------------------------------------------------------------------
    # STEP 4: RTPEngine cleanup for call teardown
    # -------------------------------------------------------------------------
    else if (is_method("BYE|CANCEL")) {
        xlog("L_INFO", "RTPEngine DELETE for Call-ID: $ci\n");
        
        # Delete the RTPEngine session to free resources
        # This stops media proxying and releases RTP ports
        rtpengine_delete();
    }

    # -------------------------------------------------------------------------
    # STEP 5: Add NAT and WebRTC parameters to Record-Route (initial requests)
    # -------------------------------------------------------------------------
    # These parameters are stored in Record-Route header so they're available
    # in subsequent in-dialog requests (like ACK, BYE, re-INVITE)
    if (is_request()) {
        # Only do this for initial requests (without to-tag)
        if(!has_totag()) {
            # Only add parameters in branch route (when selecting destination)
            if(t_is_branch_route()) {
                # Add NAT parameter to Record-Route
                add_rr_param(";nat=yes");
                
                # Add WebRTC parameter if this is a WebRTC call
                if (isflagset(8)) {
                    xlog("L_INFO", "Adding webrtc=yes to Record-Route for $ci\n");
                    add_rr_param(";webrtc=yes");
                }
            }
        }
    }
    
    # -------------------------------------------------------------------------
    # STEP 6: Handle contact aliasing for NAT traversal (replies only)
    # -------------------------------------------------------------------------
    if (is_reply()) {
        # If branch NAT flag is set
        if(isbflagset(6)) {
            # If this is the first hop (we're directly connected to the client)
            if(is_first_hop()) {
                # Add ;alias parameter to Contact header
                # This helps with NAT keepalives and routing back through NAT
                set_contact_alias();
            }
        }
    }
}

# Dialog URI route
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# REGISTRAR route
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if(isflagset(5)) {
        setbflag(6);
    }
    
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Relay route
# =============================================================================
# FIXED RELAY ROUTE - Add explicit ACK handling
# =============================================================================
route[RELAY] {
    # Special handling for ACK - just relay it, don't call NATMANAGE
    if (is_method("ACK")) {
        xlog("L_INFO", "Relaying ACK for Call-ID: $ci\n");
        if (!t_relay()) {
            sl_reply_error();
        }
        exit;
    }

    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# Branch route
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# =============================================================================
# REPLY ROUTE - Processes responses (replies) to requests
# =============================================================================
# This route handles:
# 1. RTPEngine processing for SDP answers in successful responses
# 2. Protocol conversion for WebRTC clients
# 3. Logging for debugging
# =============================================================================
onreply_route[MANAGE_REPLY] {
    # -------------------------------------------------------------------------
    # STEP 1: Log the reply for debugging
    # -------------------------------------------------------------------------
    # $rs = response status (e.g., 200, 180, 183)
    # $ci = Call-ID
    # Check WebRTC flag status and log accordingly
    if (isflagset(8)) {
        xlog("L_INFO", "===== REPLY: Status=$rs Call-ID=$ci WebRTC=YES =====\n");
    } else {
        xlog("L_INFO", "===== REPLY: Status=$rs Call-ID=$ci WebRTC=NO =====\n");
    }
    
    # -------------------------------------------------------------------------
    # STEP 2: Process successful responses (1xx and 2xx)
    # -------------------------------------------------------------------------
    # Status codes:
    # - 1xx: Provisional responses (100 Trying, 180 Ringing, 183 Session Progress)
    # - 2xx: Success responses (200 OK)
    if(status=~"[12][0-9][0-9]") {
        
        # ---------------------------------------------------------------------
        # STEP 3: Check if reply contains SDP (Session Description Protocol)
        # ---------------------------------------------------------------------
        # Only responses with SDP need RTPEngine processing
        # Examples: 183 Session Progress, 200 OK to INVITE
        # Counter-examples: 100 Trying, 180 Ringing (no SDP)
        if (has_body("application/sdp")) {
            xlog("L_INFO", "Reply has SDP body, processing with RTPEngine\n");
            xlog("L_INFO", "  Reply source: $si:$sp\n");
            
            # -----------------------------------------------------------------
            # CASE A: Reply going to WebRTC client
            # -----------------------------------------------------------------
            # The reply contains an SDP answer from the backend
            # We need to convert it to WebRTC format before sending to browser
            if (isflagset(8)) {
                xlog("L_INFO", "RTPEngine ANSWER: RTP to WebRTC conversion (Call-ID: $ci)\n");
                xlog("L_INFO", "  Adding ICE, DTLS, and rtcp-mux for WebRTC client\n");
                
                # RTPEngine parameters for answer processing:
                # - trust-address: Trust the address in SDP
                # - replace-origin: Replace o= line with RTPEngine's address
                # - replace-session-connection: Replace c= line with RTPEngine's address
                # - rtcp-mux-require: Force rtcp-mux (WebRTC requirement)
                # - ICE=force: Add ICE candidates for WebRTC
                # - DTLS=passive: DTLS handshake mode (we're passive, client is active)
                # - RTP/AVP: Input format (plain RTP from backend's answer)
                # - RTP/SAVPF: Output format (WebRTC SRTP for browser)
                $var(rtpe_result) = rtpengine_answer("trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force DTLS=passive RTP/AVP RTP/SAVPF");
                xlog("L_INFO", "  RTPEngine answer result: $var(rtpe_result)\n");
            } 
            # -----------------------------------------------------------------
            # CASE B: Reply going to regular SIP client
            # -----------------------------------------------------------------
            else {
                xlog("L_INFO", "RTPEngine ANSWER: Regular SIP (Call-ID: $ci)\n");
                
                # Simple RTPEngine processing for regular SIP
                # Just NAT traversal, no protocol conversion needed
                $var(rtpe_result) = rtpengine_answer("trust-address replace-origin replace-session-connection RTP/AVP");
                xlog("L_INFO", "  RTPEngine answer result: $var(rtpe_result)\n");
            }
            
            # -----------------------------------------------------------------
            # STEP 4: Call NATMANAGE for additional NAT handling
            # -----------------------------------------------------------------
            # This handles contact aliasing and other NAT-related tasks
            # Note: NATMANAGE knows this is a reply, so it only does reply-specific processing
            route(NATMANAGE);
        } 
        # ---------------------------------------------------------------------
        # No SDP in reply
        # ---------------------------------------------------------------------
        else {
            xlog("L_INFO", "Reply without SDP, skipping RTPEngine\n");
            # Examples: 100 Trying, 180 Ringing
            # These don't need RTPEngine processing
        }
    }
}

# Failure route
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # Try next destination
    if (t_check_status("408|503")) {
        if (ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE");
            route(RELAY);
            exit;
        }
    }
}

# xhttp event route - Handle HTTP and WebSocket upgrades
event_route[xhttp:request] {
    xlog("L_INFO", "=== XHTTP EVENT ROUTE TRIGGERED ===\n");
    xlog("L_INFO", "Method: $rm\n");
    xlog("L_INFO", "URI: $ru\n");
    xlog("L_INFO", "Headers: Upgrade=$hdr(Upgrade), Connection=$hdr(Connection)\n");
    
    # Set CORS headers for browser requests
    append_to_reply("Access-Control-Allow-Origin: *\r\n");
    append_to_reply("Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n");
    
    # Check for WebSocket upgrade
    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade") {
        xlog("L_INFO", "WebSocket upgrade request detected\n");
        
        # Handle WebSocket handshake
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake successful!\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake FAILED\n");
            xhttp_reply("500", "Internal Server Error", "text/plain", "WebSocket handshake failed");
            exit;
        }
    }
    
    # Regular HTTP request - send HTML response
    xlog("L_INFO", "Regular HTTP request - sending HTML response\n");
    xhttp_reply("200", "OK", "text/html", 
        "<html><head><title>Kamailio WebSocket Server</title></head><body><h1>Kamailio WebSocket Server</h1><p>WebSocket endpoint ready on ws://server:8080</p><p>Status: Running</p></body></html>");
}

# WebSocket event route
event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection closed for Call-ID: $ci\n");
}