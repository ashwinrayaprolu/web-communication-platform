#!KAMAILIO

# Global settings
# Listen on all interfaces
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tcp:0.0.0.0:8080

# Global parameters
debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# TCP settings
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605
tcp_max_connections=2048

# Children processes
children=4

# DNS settings
dns=no
rev_dns=no

# Module path for both architectures
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/:/usr/lib/aarch64-linux-gnu/kamailio/modules/"

# Load modules
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
#loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "permissions.so"
loadmodule "dispatcher.so"
loadmodule "dialog.so"
#loadmodule "dialplan.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "tls.so"
loadmodule "db_postgres.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "cfgutils.so"
loadmodule "corex.so"
loadmodule "kex.so"
loadmodule "sdpops.so"

# Module parameters
# TM module
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# RR module
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Registrar module
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 3600)
modparam("registrar", "received_avp", "$avp(received)")

# User location module
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "nat_bflag", 6)

# Database connection
modparam("auth_db", "db_url", "postgres://voip_user:voip_pass_2024@postgres/voip_db")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")

# Dispatcher module
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
#modparam("dispatcher", "dst_avp", "$avp(dsdst)")
#modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
#modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
#modparam("dispatcher", "attrs_avp", "$avp(dsattrs)")

# Dialog module
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "timeout_avp", "$avp(dlg_timeout)")
modparam("dialog", "default_timeout", 21600)

# WebSocket module
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)

# NAT helper
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.local")
modparam("nathelper", "received_avp", "$avp(received)")

# RTPEngine module
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_retr", 5)
modparam("rtpengine", "rtpengine_tout_ms", 1000)
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
modparam("rtpengine", "setid_avp", "$avp(setid)")

# Hash table for rate limiting
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

# Pike module for flood detection
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# Routing logic
request_route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle requests within dialogs
    if (has_totag()) {
        if (loose_route()) {
            route(DLGURI);
            if (is_method("BYE")) {
                setflag(1);
                setflag(3);
            } else if (is_method("ACK")) {
                route(NATMANAGE);
            }
            route(RELAY);
            exit;
        }

        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            } else {
                exit;
            }
        }
        sl_send_reply("404","Not here");
        exit;
    }

    # Initial INVITE
    if (is_method("INVITE")) {
        setflag(1);
        dlg_manage();
    }

    # REGISTER processing
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Dispatch to Drachtio servers
    if (is_method("INVITE")) {
        # Route to Drachtio based on extension
        if ($rU == "6000" || $rU == "9999" || $rU =~ "^555") {
            # Load balance between Drachtio servers
            if (!ds_select_dst("1", "4")) {
                send_reply("503", "Service Unavailable");
                exit;
            }
            route(RELAY);
            exit;
        }
    }

    # Handle other requests
    route(RELAY);
}

# Request initialization route
route[REQINIT] {
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP request from $si:$sp\n");
        exit;
    }
}

# NAT detection route
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
}

# NAT management route
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setflag(5);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(6))) return;

    # RTPEngine management
    if (is_method("INVITE")) {
        if ($proto == "ws" || $proto == "wss") {
            # WebRTC to RTP
            rtpengine_manage("trust-address replace-origin replace-session-connection ICE=remove RTP/AVP");
        } else {
            # RTP to WebRTC or RTP to RTP
            if (sdp_content()) {
                if (search("m=audio")) {
                    rtpengine_manage("trust-address replace-origin replace-session-connection");
                }
            }
        }
    } else if (is_method("ACK|UPDATE|PRACK")) {
        if ($proto == "ws" || $proto == "wss") {
            rtpengine_manage("trust-address replace-origin replace-session-connection ICE=remove RTP/AVP");
        } else {
            rtpengine_manage("trust-address replace-origin replace-session-connection");
        }
    } else if (is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    if (is_request()) {
        if(!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(6)) {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
    }
}

# Dialog URI route
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# REGISTRAR route
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if(isflagset(5)) {
        setbflag(6);
    }
    
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Relay route
route[RELAY] {
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Branch route
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Reply route
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Failure route
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # Try next destination
    if (t_check_status("408|503")) {
        if (ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE");
            route(RELAY);
            exit;
        }
    }
}




# xhttp event route - Handle HTTP and WebSocket upgrades
event_route[xhttp:request] {
    xlog("L_INFO", "=== XHTTP EVENT ROUTE TRIGGERED ===\n");
    xlog("L_INFO", "Method: $rm\n");
    xlog("L_INFO", "URI: $ru\n");
    xlog("L_INFO", "Headers: Upgrade=$hdr(Upgrade), Connection=$hdr(Connection)\n");
    
    # Set CORS headers for browser requests
    append_to_reply("Access-Control-Allow-Origin: *\r\n");
    append_to_reply("Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n");
    
    # Check for WebSocket upgrade
    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade") {
        xlog("L_INFO", "WebSocket upgrade request detected\n");
        
        # Handle WebSocket handshake
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake successful!\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake FAILED\n");
            xhttp_reply("500", "Internal Server Error", "text/plain", "WebSocket handshake failed");
            exit;
        }
    }
    
    # Regular HTTP request - send HTML response
    xlog("L_INFO", "Regular HTTP request - sending HTML response\n");
    xhttp_reply("200", "OK", "text/html", 
        "<html><head><title>Kamailio WebSocket Server</title></head><body><h1>Kamailio WebSocket Server</h1><p>WebSocket endpoint ready on ws://server:8080</p><p>Status: Running</p></body></html>");
}




# WebSocket event route
event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection closed\n");
}