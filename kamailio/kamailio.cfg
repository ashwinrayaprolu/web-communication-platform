#!KAMAILIO

# Global settings
# Use the actual hostname/IP that clients can reach
# Replace 'kamailio' with your actual hostname or IP
listen=tcp:0.0.0.0:8080 advertise 192.168.2.16:8080
listen=udp:0.0.0.0:5060 advertise 192.168.2.16:5060
listen=tcp:0.0.0.0:5060 advertise 192.168.2.16:5060


# Global parameters
debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# TCP settings
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605
tcp_max_connections=2048

# Children processes
children=4

# DNS settings
dns=no
rev_dns=no

# Module path for both architectures
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/:/usr/lib/aarch64-linux-gnu/kamailio/modules/"

# Load modules
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
#loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "permissions.so"
loadmodule "dispatcher.so"
loadmodule "dialog.so"
#loadmodule "dialplan.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "tls.so"
loadmodule "db_postgres.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "cfgutils.so"
loadmodule "corex.so"
loadmodule "kex.so"
loadmodule "sdpops.so"

# Module parameters
# TM module
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# RR module
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Registrar module
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 3600)
modparam("registrar", "received_avp", "$avp(received)")

# User location module
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "nat_bflag", 6)

# Database connection
modparam("auth_db", "db_url", "postgres://voip_user:voip_pass_2024@postgres/voip_db")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")

# Dispatcher module
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
#modparam("dispatcher", "dst_avp", "$avp(dsdst)")
#modparam("dispatcher", "grp_avp", "$avp(dsgrp)")
#modparam("dispatcher", "cnt_avp", "$avp(dscnt)")
#modparam("dispatcher", "attrs_avp", "$avp(dsattrs)")

# Dialog module
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "timeout_avp", "$avp(dlg_timeout)")
modparam("dialog", "default_timeout", 21600)

# WebSocket module
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)

# NAT helper
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.local")
modparam("nathelper", "received_avp", "$avp(received)")

# RTPEngine module
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")
modparam("rtpengine", "rtpengine_disable_tout", 20)
modparam("rtpengine", "rtpengine_retr", 5)
modparam("rtpengine", "rtpengine_tout_ms", 1000)
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")
modparam("rtpengine", "setid_avp", "$avp(setid)")

# Hash table for rate limiting
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

# Pike module for flood detection
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# =============================================================================
# Add at the top with other modparams
# =============================================================================
# Advertise proper addresses in Record-Route
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# =============================================================================
# FLAG DEFINITIONS
# =============================================================================
# Flag 1: acc transaction
# Flag 3: acc failed transaction
# Flag 4: dialog
# Flag 5: NAT flag
# Flag 6: NAT bflag (branch flag)
# Flag 7: sipping flag
# Flag 8: WebRTC flag (NEW - marks WebRTC clients)
# =============================================================================

# Routing logic
request_route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle requests within dialogs
    if (has_totag()) {
        if (loose_route()) {
            route(DLGURI);
            
            # Restore WebRTC flag from route param
            if(check_route_param("webrtc=yes")) {
                xlog("L_INFO", "Restoring WebRTC flag from route param for $ci\n");
                setflag(8);
            }
            
            if (is_method("BYE")) {
                setflag(1);
                setflag(3);
                route(NATMANAGE);  # Call NATMANAGE for BYE (to delete RTPEngine session)
            } else if (is_method("ACK")) {
                # ✅ FIXED: Don't call NATMANAGE for ACK - just relay it
                xlog("L_INFO", "In-dialog ACK detected, relaying without RTPEngine processing\n");
            }
            route(RELAY);
            exit;
        }

        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            } else {
                exit;
            }
        }
        sl_send_reply("404","Not here");
        exit;
    }

    # Initial INVITE
    if (is_method("INVITE")) {
        setflag(1);
        dlg_manage();
    }

    # REGISTER processing
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # ============================================================
    # INVITE PROCESSING WITH LOOP PREVENTION
    # ============================================================
    if (is_method("INVITE")) {
        
        # **CRITICAL: LOOP PREVENTION - Check if call is FROM Drachtio/App**
        # Detect by: X-Call-ID header (added by your Node.js app) OR X-From-App header
        if (is_present_hf("X-Call-ID") || is_present_hf("X-From-App")) {
            xlog("L_INFO", "===== CALL FROM APP/DRACHTIO (BRIDGED): $ci =====\n");
            xlog("L_INFO", "Destination: $rU - Routing directly to registered extension\n");
            
            # This is a bridged call from the app, route directly to destination
            if (registered("location")) {
                xlog("L_INFO", "Extension $rU is registered, routing directly (NO LOOP)\n");
                
                # Lookup the location - this sets $ru to the contact URI
                lookup("location");
                
                # After lookup, $ru contains the actual contact address
                # Check if it contains WebSocket transport
                xlog("L_INFO", "Contact URI after lookup: $ru\n");
                xlog("L_INFO", "Destination URI: $du\n");
                
                # WebRTC clients will have transport=ws or transport=wss in their contact
                if ($ru =~ "transport=ws" || $ru =~ "transport=wss") {
                    xlog("L_INFO", "*** TARGET IS WEBRTC CLIENT - Setting WebRTC flag ***\n");
                    setflag(8);  # Mark as WebRTC for proper RTPEngine handling
                    setflag(5);  # Also set NAT flag
                } else {
                    xlog("L_INFO", "Target extension $rU is regular SIP client\n");
                }
                
                # NATMANAGE will be called in branch_route which will handle RTPEngine
                route(RELAY);
                exit;
            } else {
                xlog("L_WARN", "Extension $rU not registered, returning 404\n");
                send_reply("404", "User Not Found");
                exit;
            }
        }
        
        # **ALL INCOMING CALLS: Route to Drachtio first**
        # Drachtio/App will decide whether to bridge or handle the call
        xlog("L_INFO", "===== NEW INCOMING CALL: $ci =====\n");
        xlog("L_INFO", "From: $fU To: $rU Protocol: $proto\n");
        xlog("L_INFO", "Routing ALL calls to Drachtio for app processing\n");
        
        # Add header to mark this call as initial routing
        append_hf("X-Kamailio-Route: initial\r\n");
        
        # Load balance between Drachtio servers
        if (!ds_select_dst("1", "4")) {
            xlog("L_ERR", "Failed to select Drachtio destination\n");
            send_reply("503", "Service Unavailable - No Drachtio servers available");
            exit;
        }
        
        xlog("L_INFO", "Selected Drachtio destination: $du\n");
        route(RELAY);
        exit;
    }

    # Handle other requests
    route(RELAY);
}

# Request initialization route
route[REQINIT] {
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP request from $si:$sp\n");
        exit;
    }
}

# NAT detection route
route[NATDETECT] {
    force_rport();
    
    # Detect WebRTC clients (WebSocket transport)
    if ($proto == "ws" || $proto == "wss") {
        xlog("L_INFO", "WebRTC client detected (WebSocket transport) for $ci\n");
        setflag(8);  # Mark as WebRTC
        setflag(5);  # Also set NAT flag
    }
    
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
}

# NAT management route
# =============================================================================
# FIXED NAT MANAGEMENT ROUTE
# =============================================================================
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setflag(5);
            }
            # Restore WebRTC flag from route param
            if(check_route_param("webrtc=yes")) {
                setflag(8);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(6))) return;

    # RTPEngine management
    if (is_method("INVITE")) {
        if (isflagset(8)) {
            # This leg involves WebRTC
            if ($proto == "ws" || $proto == "wss") {
                # Incoming from WebRTC client -> Convert to plain RTP for backend
                xlog("L_INFO", "RTPEngine OFFER: WebRTC to RTP conversion (Call-ID: $ci)\n");
                rtpengine_offer("trust-address replace-origin replace-session-connection rtcp-mux-demux ICE=remove DTLS=off RTP/SAVPF RTP/AVP");
            } else {
                # Outgoing to WebRTC client -> Convert from plain RTP to WebRTC
                xlog("L_INFO", "RTPEngine OFFER: RTP to WebRTC conversion (Call-ID: $ci)\n");
                rtpengine_offer("trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force DTLS=passive RTP/AVP RTP/SAVPF");
            }
        } else {
            # Regular SIP client
            if (sdp_content()) {
                xlog("L_INFO", "RTPEngine OFFER: Regular SIP (Call-ID: $ci)\n");
                rtpengine_offer("trust-address replace-origin replace-session-connection RTP/AVP");
            }
        }
    } 
    # ❌ REMOVED THE BROKEN ACK HANDLING
    # ACK messages don't have SDP, so we should NOT call rtpengine_answer()
    # The ACK just needs to be relayed normally
    else if (is_method("UPDATE|PRACK")) {
        if (isflagset(8)) {
            rtpengine_manage("trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force DTLS=passive RTP/SAVPF");
        } else {
            rtpengine_manage("trust-address replace-origin replace-session-connection RTP/AVP");
        }
    } else if (is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    if (is_request()) {
        if(!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
                # Save WebRTC flag in route param
                if (isflagset(8)) {
                    xlog("L_INFO", "Adding webrtc=yes to Record-Route for $ci\n");
                    add_rr_param(";webrtc=yes");
                }
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(6)) {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
    }
}

# Dialog URI route
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# REGISTRAR route
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if(isflagset(5)) {
        setbflag(6);
    }
    
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Relay route
# =============================================================================
# FIXED RELAY ROUTE - Add explicit ACK handling
# =============================================================================
route[RELAY] {
    # Special handling for ACK - just relay it, don't call NATMANAGE
    if (is_method("ACK")) {
        xlog("L_INFO", "Relaying ACK for Call-ID: $ci\n");
        if (!t_relay()) {
            sl_reply_error();
        }
        exit;
    }

    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# Branch route
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Reply route - CRITICAL: Handles WebRTC conversion back to client
onreply_route[MANAGE_REPLY] {
    if (isflagset(8)) {
        xlog("L_INFO", "===== REPLY: Status=$rs Call-ID=$ci WebRTC=YES =====\n");
    } else {
        xlog("L_INFO", "===== REPLY: Status=$rs Call-ID=$ci WebRTC=NO =====\n");
    }
    
    if(status=~"[12][0-9][0-9]") {
        # Handle RTPEngine ONLY for successful responses with SDP
        if (has_body("application/sdp")) {
            xlog("L_INFO", "Reply has SDP body, processing with RTPEngine\n");
            
            if (isflagset(8)) {
                # Response going back to WebRTC client - Convert RTP back to WebRTC
                xlog("L_INFO", "RTPEngine ANSWER: RTP to WebRTC conversion (Call-ID: $ci)\n");
                xlog("L_INFO", "Adding ICE, DTLS, and rtcp-mux for WebRTC client\n");
                rtpengine_answer("trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force DTLS=passive RTP/AVP RTP/SAVPF");
            } else {
                # Response going to regular SIP client
                xlog("L_INFO", "RTPEngine ANSWER: Regular SIP (Call-ID: $ci)\n");
                rtpengine_answer("trust-address replace-origin replace-session-connection RTP/AVP");
            }
            
            # Only call NATMANAGE for replies with SDP
            route(NATMANAGE);
        } else {
            xlog("L_INFO", "Reply without SDP, skipping RTPEngine\n");
        }
    }
}

# Failure route
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # Try next destination
    if (t_check_status("408|503")) {
        if (ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE");
            route(RELAY);
            exit;
        }
    }
}

# xhttp event route - Handle HTTP and WebSocket upgrades
event_route[xhttp:request] {
    xlog("L_INFO", "=== XHTTP EVENT ROUTE TRIGGERED ===\n");
    xlog("L_INFO", "Method: $rm\n");
    xlog("L_INFO", "URI: $ru\n");
    xlog("L_INFO", "Headers: Upgrade=$hdr(Upgrade), Connection=$hdr(Connection)\n");
    
    # Set CORS headers for browser requests
    append_to_reply("Access-Control-Allow-Origin: *\r\n");
    append_to_reply("Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n");
    
    # Check for WebSocket upgrade
    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade") {
        xlog("L_INFO", "WebSocket upgrade request detected\n");
        
        # Handle WebSocket handshake
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake successful!\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake FAILED\n");
            xhttp_reply("500", "Internal Server Error", "text/plain", "WebSocket handshake failed");
            exit;
        }
    }
    
    # Regular HTTP request - send HTML response
    xlog("L_INFO", "Regular HTTP request - sending HTML response\n");
    xhttp_reply("200", "OK", "text/html", 
        "<html><head><title>Kamailio WebSocket Server</title></head><body><h1>Kamailio WebSocket Server</h1><p>WebSocket endpoint ready on ws://server:8080</p><p>Status: Running</p></body></html>");
}

# WebSocket event route
event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection closed for Call-ID: $ci\n");
}